<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‚¬ì£¼ ì§€ì‹ ë´‡ (CRT Style - ìë™ PDF ë¡œë“œ)</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">

    <script src="config.js"></script>

    <style>
        /* --- Basic CRT Styling (ìŠ¤íƒ€ì¼ì€ ì´ì „ê³¼ ê±°ì˜ ë™ì¼) --- */
        body {
            color: #00ff00;
            font-family: 'Lucida Console', 'Courier New', monospace;
            margin: 0; padding: 0;
            background-color: #000000;
            background-image: url('matrix.png'); /* ë°°ê²½ ì´ë¯¸ì§€ ê²½ë¡œ í™•ì¸ */
            background-repeat: no-repeat;
            background-size: cover;
            background-position: center center;
            background-attachment: fixed;
            font-size: 15px;
        }
        .crt-container {
            border: 8px solid #00cc00;
            border-radius: 4px;
            box-sizing: border-box;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.85);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .chat-box {
            border: 1px solid #00cc00;
            background-color: rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            min-height: 300px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }
        .chat-box::-webkit-scrollbar { width: 8px; }
        .chat-box::-webkit-scrollbar-track { background-color: #001a00; }
        .chat-box::-webkit-scrollbar-thumb { background-color: #00cc00; border: 1px solid #001a00; }

        .user-message,
        .bot-message {
            max-width: 80%;
            margin-bottom: 10px;
            border: 1px solid #00cc00;
            border-radius: 6px;
            padding: 10px 14px;
            color: #00ff00;
            word-break: break-word;
            line-height: 1.6;
            background-color: #001000;
        }
        .user-message { margin-left: auto; margin-right: 0; background-color: #001f00; }
        .bot-message { margin-left: 0; margin-right: auto; }
        .bot-message strong { color: #80ff80; }
        .bot-message code { background-color: #002a00; padding: 2px 4px; border-radius: 3px; }

        /* íŒŒì¼ ì…ë ¥ ê´€ë ¨ UI ì œê±°ë¨ */

        .chat-input-container {
            border-top: 1px solid #00cc00;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-input {
            background-color: #000000;
            color: #00ff00;
            font-family: inherit;
            border: 1px solid #00ff00;
            padding: 10px;
            flex-grow: 1;
            outline: none;
            box-sizing: border-box;
        }
        .chat-send-button {
            background-color: #000000;
            color: #00ff00;
            font-family: inherit;
            border: 1px solid #00ff00;
            padding: 10px 15px;
            cursor: pointer;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }
        .chat-send-button:hover { opacity: 0.8; }
        .chat-send-button:disabled { opacity: 0.4; cursor: not-allowed; }

        /* --- Status UI --- */
        #status-container {
            border: 1px dashed #00cc00;
            padding: 6px 10px;
            margin-bottom: 10px;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            color: #00ff00;
            font-size: 0.9rem;
        }
        #status-container .status-icon {
            width: 20px;
            text-align: center;
            margin-right: 0.7rem;
            animation: spin 1.5s linear infinite;
        }
        #status-container .status-icon .fas { font-size: 1.1em; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .footer {
             margin-top: 10px;
             padding-top: 5px;
             border-top: 1px solid #003300;
             text-align: center;
             font-size: 0.8rem;
             color: #008000;
        }
        .error-message { color: #ff4d4d !important; } /* Important to override other styles */
    </style>
</head>

<body>
<div class="container mx-auto px-4 py-4 max-w-5xl crt-container">
    <h1 class="text-2xl mb-4 text-center" style="color:#00ff00;">ì‚¬ì£¼ ê³ ì¸ë¬¼</h1>

    <div id="chat-box" class="chat-box">
        <div class="bot-message">
            ì•ˆë…•í•˜ì„¸ìš”! ì‚¬ì£¼ ê³ ì¸ë¬¼ì…ë‹ˆë‹¤.
            ë¬´ì—‡ì´ ê¶ê¸ˆí•˜ì‹ ê°€ìš”?
            <br><strong class="error-message"></strong>
            <br><strong class="error-message">ğŸ’¡ ì‹¤í–‰ ì°¸ê³ : ì´ í˜ì´ì§€ëŠ” ì›¹ ì„œë²„ í™˜ê²½ì—ì„œ ì‹¤í–‰ë˜ì–´ì•¼ PDF íŒŒì¼ì„ ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì˜ˆ: Python http.server, VS Code Live Server)</strong>
        </div>
    </div>

    <div class="chat-input-container no-print">
        <input type="text" id="user-input" class="chat-input" placeholder="ì‚¬ì£¼ ì§€ì‹ì— ëŒ€í•´ ì§ˆë¬¸í•´ì£¼ì„¸ìš”...">
        <button id="send-button" class="chat-send-button">Send</button> </div>

    <div class="footer no-print">
         Â© ì‚¬ì£¼ ê³ ì¸ë¬¼  
    </div>
</div>

<script>
/* ======== CONFIG & BASIC SETUP ======== */
const DEBUG = true;
function log(...args) {
    if (DEBUG) {
        console.log(`[PDF Bot Log ${new Date().toLocaleTimeString()}]`, ...args);
    }
}

// --- Security & Usage Warning ---
console.warn("ğŸš¨ SECURITY WARNING: Gemini API Key is exposed in client-side JavaScript. DO NOT USE IN PRODUCTION. Consider using a backend proxy.");
console.warn("ğŸ’¡ USAGE NOTE: This HTML file must be served via a web server (e.g., `python -m http.server` or VS Code Live Server) for PDF fetching to work. Opening it as a `file:///` will likely fail.");
// alert("ğŸš¨ ğŸ’¡ ì‹¤í–‰ ì°¸ê³ : ì´ í˜ì´ì§€ëŠ” ì›¹ ì„œë²„ í™˜ê²½ì—ì„œ ì‹¤í–‰ë˜ì–´ì•¼ PDF íŒŒì¼ì„ ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");

// *** ì¤‘ìš”: HTML íŒŒì¼ê³¼ ë™ì¼í•œ ë””ë ‰í† ë¦¬ì— ìˆëŠ” PDF íŒŒì¼ì˜ ì´ë¦„ì„ ì§€ì •í•˜ì„¸ìš” ***
const PREDEFINED_PDF_FILENAME = 'saju_knowledge.pdf'; // <--- ì—¬ê¸°ì— PDF íŒŒì¼ ì´ë¦„ ì…ë ¥!

// Get Gemini API Key from config.js
const geminiApiKey = window.apiKeys?.GEMINI_API_KEY;

if (!geminiApiKey) {
    console.error("Gemini API Key is not set in config.js");
    const errorDiv = document.createElement('div');
    errorDiv.className = 'bot-message error-message';
    errorDiv.innerHTML = '<strong>ì¹˜ëª…ì  ì˜¤ë¥˜:</strong> Gemini API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. config.js íŒŒì¼ì„ í™•ì¸í•˜ì„¸ìš”.';
    document.getElementById('chat-box').appendChild(errorDiv);
    throw new Error("Missing Gemini API Key");
}

// --- Global Variable for Uploaded File URI ---
let uploadedFileUri = null; // Store the URI after successful upload
let lastUploadedPdfName = null; // Track which PDF name was last uploaded

// DOM Elements
const chatBox = document.getElementById('chat-box');
const userInput = document.getElementById('user-input');
const sendButton = document.getElementById('send-button');
// pdfInput, selectedFileNameSpan ì œê±°ë¨
const chatInputContainer = document.querySelector('.chat-input-container');


// --- Message Display Functions ---
function escapeHtml(unsafe) { /* ... (ì´ì „ê³¼ ë™ì¼) ... */ }
function addUserMessage(text) { /* ... (ì´ì „ê³¼ ë™ì¼) ... */ }
function addBotMessage(htmlContent) { /* ... (ì´ì „ê³¼ ë™ì¼) ... */ }
function addErrorMessage(message) { /* ... (ì´ì „ê³¼ ë™ì¼) ... */ }
function scrollToBottom() { /* ... (ì´ì „ê³¼ ë™ì¼, ì•½ê°„ì˜ ì§€ì—° í¬í•¨) ... */ }

// --- Status UI ---
function createStatusUI(message = "ì²˜ë¦¬ ì¤‘...") {
    removeStatusUI();
    const container = document.createElement('div');
    container.id = 'status-container';
    container.innerHTML = `
        <span class="status-icon"><i class="fas fa-spinner fa-spin"></i></span>
        <span class="status-label">${escapeHtml(message)}</span>
    `;
    // Insert status UI *before* the chat input container now
    chatInputContainer.parentNode.insertBefore(container, chatInputContainer);
    scrollToBottom();
}
function removeStatusUI() { /* ... (ì´ì „ê³¼ ë™ì¼) ... */ }

// --- Loading State ---
function setLoadingState(isLoading, statusMessage = "ì²˜ë¦¬ ì¤‘...") {
    userInput.disabled = isLoading;
    sendButton.disabled = isLoading;
    // íŒŒì¼ ì…ë ¥ ê´€ë ¨ UI ë¹„í™œì„±í™” ì œê±°

    if (isLoading) {
        createStatusUI(statusMessage);
    } else {
        removeStatusUI();
        if (!userInput.disabled) {
             userInput.focus();
        }
    }
    scrollToBottom();
}

/* ======== PDF File Handling (Fetching Predefined File) ======== */

// **Function to Fetch and Upload the Predefined PDF**
async function fetchAndUploadPredefinedPdf(pdfFilename) {
    // Optimization: If the same PDF was already uploaded, reuse the URI
    // Note: URIs might expire, so this is a basic optimization.
    // A more robust solution would check URI validity or re-upload periodically.
    if (uploadedFileUri && lastUploadedPdfName === pdfFilename) {
         log(`Reusing previously uploaded URI for ${pdfFilename}: ${uploadedFileUri}`);
         return uploadedFileUri;
    }

    log(`Attempting to fetch predefined PDF: ${pdfFilename}`);
    setLoadingState(true, `ì‚¬ì „ ì •ì˜ëœ PDF ë¡œë“œ ì¤‘: ${pdfFilename}...`);

    let pdfBlob;
    try {
        // Fetch the PDF file using its relative path (works only when served via HTTP/S)
        const response = await fetch(pdfFilename); // Request the file relative to the HTML

        if (!response.ok) {
            // Handle common errors like 404 Not Found
            let errorMsg = `HTTP error! Status: ${response.status}`;
             if (response.status === 404) {
                 errorMsg = `ì˜¤ë¥˜: PDF íŒŒì¼ '${pdfFilename}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. HTML íŒŒì¼ê³¼ ê°™ì€ ë””ë ‰í† ë¦¬ì— ìˆëŠ”ì§€, íŒŒì¼ ì´ë¦„ì´ ì •í™•í•œì§€, ì›¹ ì„œë²„ê°€ íŒŒì¼ì„ ì œê³µí•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.`;
             } else if (response.status === 0) { // Often indicates CORS or network error when using file:///
                 errorMsg = `ì˜¤ë¥˜: PDF íŒŒì¼ '${pdfFilename}' ë¡œë“œ ì‹¤íŒ¨. ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë˜ëŠ” CORS ì •ì±… ë•Œë¬¸ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í˜ì´ì§€ê°€ ì›¹ ì„œë²„ë¥¼ í†µí•´ ì œê³µë˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš” (file:/// ê²½ë¡œ ì•„ë‹˜).`;
             }
            throw new Error(errorMsg);
        }

        pdfBlob = await response.blob(); // Get the file content as a Blob
        log(`Successfully fetched PDF: ${pdfFilename}, Size: ${pdfBlob.size}, Type: ${pdfBlob.type}`);

        if (pdfBlob.size === 0) {
            throw new Error(`ì˜¤ë¥˜: ê°€ì ¸ì˜¨ PDF íŒŒì¼ '${pdfFilename}'ì˜ ë‚´ìš©ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.`);
        }

    } catch (error) {
        log(`Error fetching predefined PDF '${pdfFilename}':`, error);
        addErrorMessage(`ì‚¬ì „ ì •ì˜ëœ PDF ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
        setLoadingState(false); // Stop loading on fetch failure
        return null; // Indicate failure
    }

    // Now Upload the fetched Blob
    try {
        // Create a File object from the Blob to easily pass name and type
        const pdfFileObject = new File([pdfBlob], pdfFilename, { type: pdfBlob.type || 'application/pdf' });

        // Call the existing upload function
        const fileUri = await uploadPdfToGeminiInternal(pdfFileObject); // Renamed internal function

        if (fileUri) {
             lastUploadedPdfName = pdfFilename; // Store the name of the successfully uploaded PDF
        } else {
            lastUploadedPdfName = null; // Clear if upload failed
        }
        return fileUri;

    } catch (error) {
         // uploadPdfToGeminiInternal already logs and shows messages
         log("Error during upload after fetching:", error);
         lastUploadedPdfName = null;
         // Ensure loading state is turned off if upload fails here
         setLoadingState(false);
         return null;
    }
}


/* ======== GEMINI API INTERACTION (using REST API) ======== */

// **Internal Function to Upload PDF Blob/File using REST API**
// (Renamed from uploadPdfToGemini to avoid confusion)
async function uploadPdfToGeminiInternal(fileObject) { // Expects a File or Blob object
    if (!fileObject) return null;

    const fileName = fileObject.name || 'predefined.pdf'; // Use name from File object or default
    log(`Uploading PDF data for: ${fileName}`);
    // Update status message more accurately
    setLoadingState(true, `Gemini APIë¡œ PDF ì—…ë¡œë“œ ì¤‘: ${fileName}...`);

    const uploadUrl = `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${geminiApiKey}`;

    try {
        const response = await fetch(uploadUrl, {
            method: 'POST',
            headers: {
                'Content-Type': fileObject.type || 'application/pdf',
                'X-Goog-Upload-File-Name': encodeURIComponent(fileName)
            },
            body: fileObject // Send the File or Blob object
        });

        const data = await response.json();

        if (!response.ok || data.error) {
            let errorMsg = `File API Error: ${data.error?.message || `HTTP ${response.status}`}`;
            // ... (rest of error handling as before) ...
             if (data.error?.details) { /* ... */ }
             if (response.status === 403) { /* ... */ }
            throw new Error(errorMsg);
        }

        const uploadedFile = data.file || data;
        if (!uploadedFile || !uploadedFile.uri) {
             console.error("Unexpected upload response structure:", data);
            throw new Error("File API Error: Upload response did not contain expected file URI.");
        }

        log(`PDF Uploaded Successfully. URI: ${uploadedFile.uri}`);
        uploadedFileUri = uploadedFile.uri; // Update global URI
        return uploadedFileUri;

    } catch (error) {
        log('PDF Upload Error:', error);
        // Modify error message slightly for context
        addErrorMessage(`PDF íŒŒì¼ ì—…ë¡œë“œ ì‹¤íŒ¨ (${fileName}): ${error.message}. CORS, API í‚¤, ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.`);
        uploadedFileUri = null;
        return null;
    }
    // Keep loading state, processMessage will handle turning it off
}

// **Function to get response based on uploaded PDF and question**
// (This function remains largely the same, just takes question and fileUri)
async function getGeminiResponsePdf(question, fileUri) {
    if (!geminiApiKey) return "ì˜¤ë¥˜: Gemini API í‚¤ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.";
    if (!fileUri) return "ì˜¤ë¥˜: PDF íŒŒì¼ URIê°€ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.";

    log(`Sending request to Gemini with PDF URI: ${fileUri} and Question: ${question}`);
    setLoadingState(true, "Gemini ë¶„ì„ ì¤‘...");

    const systemPrompt = `ë‹¹ì‹ ì€ "${PREDEFINED_PDF_FILENAME}" PDF ë¬¸ì„œì˜ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì˜ ì§ˆë¬¸ì— í•œêµ­ì–´ë¡œ ë‹µë³€í•˜ëŠ” AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤.
- ì œê³µëœ PDF íŒŒì¼("fileData")ì˜ ë‚´ìš©ì„ ë¶„ì„í•˜ê³  ì‚¬ìš©ìì˜ ì§ˆë¬¸("text")ì— ë‹µí•˜ì„¸ìš”.
- ë‹µë³€ì€ ë°˜ë“œì‹œ PDF íŒŒì¼ ë‚´ì˜ ì •ë³´ì— ê·¼ê±°í•´ì•¼ í•©ë‹ˆë‹¤. íŒŒì¼ì— ì—†ëŠ” ë‚´ìš©ì€ ë‹µë³€í•˜ì§€ ë§ˆì„¸ìš”.
- ë‹µë³€ì€ ëª…í™•í•˜ê³  ê°„ê²°í•˜ê²Œ, ì „ë¬¸ê°€ì ì¸ í†¤ìœ¼ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”.
- Markdown í˜•ì‹ì„ ì‚¬ìš©í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤(êµµê²Œ, ê¸°ìš¸ì„, ëª©ë¡ ë“±).`;

    const reqBody = {
        contents: [{
            role: "user",
            parts: [
                { text: `${systemPrompt}\n\nì§ˆë¬¸: ${question}` },
                 { fileData: { mimeType: "application/pdf", fileUri: fileUri } }
             ]
        }],
        safetySettings: [ /* ... (Standard safety settings) ... */ ],
        generationConfig: { temperature: 0.6 }
    };

    const model = "gemini-1.5-flash-latest";
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

    try {
        const resp = await fetch(url, {
            method: 'POST',
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(reqBody)
        });
        const data = await resp.json();

        // --- Error Handling (as before) ---
        if (!resp.ok || data.error) { /* ... (Detailed error handling) ... */ throw new Error(`Gemini API ì˜¤ë¥˜: ${errorDetail}`); }
        if (!data.candidates || !data.candidates[0].content /* ... */) { /* ... (Handle empty/blocked response) ... */ return `ì˜¤ë¥˜: Geminië¡œë¶€í„° ë¹„ì–´ ìˆê±°ë‚˜ ì°¨ë‹¨ëœ ì‘ë‹µ...`; }

        let answer = data.candidates[0].content.parts[0].text;
        log("Geminië¡œë¶€í„° PDF ê¸°ë°˜ ì‘ë‹µ ìˆ˜ì‹  ì™„ë£Œ.");

        // --- Markdown to HTML ---
        answer = answer.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') /* ... (rest of markdown conversion) ... */;
        return answer;

    } catch (err) {
        log('Gemini API fetch error:', err);
        // Use addErrorMessage directly here as it's the final step failure
        addErrorMessage(`Gemini í†µì‹  ì˜¤ë¥˜: ${err.message}`);
        return null; // Indicate failure
    }
}

/* ======== MAIN MESSAGE PROCESSING ======== */
async function processMessage() {
    const userQuestion = userInput.value.trim();
    if (!userQuestion) return;

    addUserMessage(userQuestion);
    userInput.value = '';
    userInput.blur();

    setLoadingState(true, "ì‘ì—… ì¤€ë¹„ ì¤‘..."); // Initial state

    try {
        // 1. Fetch and Upload the *Predefined* PDF
        // The function now handles fetching and uploading internally
        const currentFileUri = await fetchAndUploadPredefinedPdf(PREDEFINED_PDF_FILENAME);

        if (!currentFileUri) {
            // Error message already shown by fetch or upload functions
            // Ensure loading state is off if fetch/upload failed early
            setLoadingState(false);
            return; // Stop processing
        }

        // 2. Get Response from Gemini using the obtained file URI
        const botResponse = await getGeminiResponsePdf(userQuestion, currentFileUri);

        // 3. Display Response or handle error
        if (botResponse) { // Check if response is not null (null indicates fetch error handled previously)
             if (botResponse.startsWith("ì˜¤ë¥˜:")) {
                  addErrorMessage(botResponse.replace(/^ì˜¤ë¥˜:\s*/, ''));
             } else {
                 addBotMessage(botResponse);
             }
        }
        // If botResponse is null, error was already displayed by getGeminiResponsePdf

    } catch (error) {
         // Catch any unexpected errors during the process
         log("Unexpected error in processMessage:", error);
         addErrorMessage(`ì²˜ë¦¬ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: ${error.message}`);
    } finally {
        // 4. Reset Loading State (ensure it's always turned off)
        setLoadingState(false);
    }
}

/* ======== EVENT LISTENERS ======== */
function handleSend() {
    const msg = userInput.value.trim();
    if (!sendButton.disabled && msg) { // Only check if not loading and message exists
        processMessage();
    } else if (!msg) {
        addErrorMessage("ì§ˆë¬¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
    }
}

sendButton.addEventListener('click', handleSend);

userInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSend();
    }
});

// --- Initial Setup ---
userInput.focus();
log(`ì‚¬ì „ ì •ì˜ëœ PDF ë´‡ ì´ˆê¸°í™” ì™„ë£Œ. ì‚¬ìš©í•  PDF: ${PREDEFINED_PDF_FILENAME}. ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”.`);

</script>
</body>
</html>
