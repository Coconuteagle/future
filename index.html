<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사주 지식 봇 (CRT Style - 자동 PDF 로드)</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">

    <script src="config.js"></script>

    <style>
        /* --- Basic CRT Styling (스타일은 이전과 거의 동일) --- */
        body {
            color: #00ff00;
            font-family: 'Lucida Console', 'Courier New', monospace;
            margin: 0; padding: 0;
            background-color: #000000;
            background-image: url('matrix.png'); /* 배경 이미지 경로 확인 */
            background-repeat: no-repeat;
            background-size: cover;
            background-position: center center;
            background-attachment: fixed;
            font-size: 15px;
        }
        .crt-container {
            border: 8px solid #00cc00;
            border-radius: 4px;
            box-sizing: border-box;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.85);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .chat-box {
            border: 1px solid #00cc00;
            background-color: rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            min-height: 300px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }
        .chat-box::-webkit-scrollbar { width: 8px; }
        .chat-box::-webkit-scrollbar-track { background-color: #001a00; }
        .chat-box::-webkit-scrollbar-thumb { background-color: #00cc00; border: 1px solid #001a00; }

        .user-message,
        .bot-message {
            max-width: 80%;
            margin-bottom: 10px;
            border: 1px solid #00cc00;
            border-radius: 6px;
            padding: 10px 14px;
            color: #00ff00;
            word-break: break-word;
            line-height: 1.6;
            background-color: #001000;
        }
        .user-message { margin-left: auto; margin-right: 0; background-color: #001f00; }
        .bot-message { margin-left: 0; margin-right: auto; }
        .bot-message strong { color: #80ff80; }
        .bot-message code { background-color: #002a00; padding: 2px 4px; border-radius: 3px; }

        /* 파일 입력 관련 UI 제거됨 */

        .chat-input-container {
            border-top: 1px solid #00cc00;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-input {
            background-color: #000000;
            color: #00ff00;
            font-family: inherit;
            border: 1px solid #00ff00;
            padding: 10px;
            flex-grow: 1;
            outline: none;
            box-sizing: border-box;
        }
        .chat-send-button {
            background-color: #000000;
            color: #00ff00;
            font-family: inherit;
            border: 1px solid #00ff00;
            padding: 10px 15px;
            cursor: pointer;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }
        .chat-send-button:hover { opacity: 0.8; }
        .chat-send-button:disabled { opacity: 0.4; cursor: not-allowed; }

        /* --- Status UI --- */
        #status-container {
            border: 1px dashed #00cc00;
            padding: 6px 10px;
            margin-bottom: 10px;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            color: #00ff00;
            font-size: 0.9rem;
        }
        #status-container .status-icon {
            width: 20px;
            text-align: center;
            margin-right: 0.7rem;
            animation: spin 1.5s linear infinite;
        }
        #status-container .status-icon .fas { font-size: 1.1em; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .footer {
             margin-top: 10px;
             padding-top: 5px;
             border-top: 1px solid #003300;
             text-align: center;
             font-size: 0.8rem;
             color: #008000;
        }
        .error-message { color: #ff4d4d !important; } /* Important to override other styles */
    </style>
</head>

<body>
<div class="container mx-auto px-4 py-4 max-w-5xl crt-container">
    <h1 class="text-2xl mb-4 text-center" style="color:#00ff00;">사주 고인물</h1>

    <div id="chat-box" class="chat-box">
        <div class="bot-message">
            안녕하세요! 사주 고인물입니다.
            무엇이 궁금하신가요?
            <br><strong class="error-message"></strong>
            <br><strong class="error-message">💡 실행 참고: 이 페이지는 웹 서버 환경에서 실행되어야 PDF 파일을 로드할 수 있습니다. (예: Python http.server, VS Code Live Server)</strong>
        </div>
    </div>

    <div class="chat-input-container no-print">
        <input type="text" id="user-input" class="chat-input" placeholder="사주 지식에 대해 질문해주세요...">
        <button id="send-button" class="chat-send-button">Send</button> </div>

    <div class="footer no-print">
         © 사주 고인물  
    </div>
</div>

<script>
/* ======== CONFIG & BASIC SETUP ======== */
const DEBUG = true;
function log(...args) {
    if (DEBUG) {
        console.log(`[PDF Bot Log ${new Date().toLocaleTimeString()}]`, ...args);
    }
}

// --- Security & Usage Warning ---
console.warn("🚨 SECURITY WARNING: Gemini API Key is exposed in client-side JavaScript. DO NOT USE IN PRODUCTION. Consider using a backend proxy.");
console.warn("💡 USAGE NOTE: This HTML file must be served via a web server (e.g., `python -m http.server` or VS Code Live Server) for PDF fetching to work. Opening it as a `file:///` will likely fail.");
// alert("🚨 💡 실행 참고: 이 페이지는 웹 서버 환경에서 실행되어야 PDF 파일을 로드할 수 있습니다.");

// *** 중요: HTML 파일과 동일한 디렉토리에 있는 PDF 파일의 이름을 지정하세요 ***
const PREDEFINED_PDF_FILENAME = 'saju_knowledge.pdf'; // <--- 여기에 PDF 파일 이름 입력!

// Get Gemini API Key from config.js
const geminiApiKey = window.apiKeys?.GEMINI_API_KEY;

if (!geminiApiKey) {
    console.error("Gemini API Key is not set in config.js");
    const errorDiv = document.createElement('div');
    errorDiv.className = 'bot-message error-message';
    errorDiv.innerHTML = '<strong>치명적 오류:</strong> Gemini API 키가 설정되지 않았습니다. config.js 파일을 확인하세요.';
    document.getElementById('chat-box').appendChild(errorDiv);
    throw new Error("Missing Gemini API Key");
}

// --- Global Variable for Uploaded File URI ---
let uploadedFileUri = null; // Store the URI after successful upload
let lastUploadedPdfName = null; // Track which PDF name was last uploaded

// DOM Elements
const chatBox = document.getElementById('chat-box');
const userInput = document.getElementById('user-input');
const sendButton = document.getElementById('send-button');
// pdfInput, selectedFileNameSpan 제거됨
const chatInputContainer = document.querySelector('.chat-input-container');


// --- Message Display Functions ---
function escapeHtml(unsafe) { /* ... (이전과 동일) ... */ }
function addUserMessage(text) { /* ... (이전과 동일) ... */ }
function addBotMessage(htmlContent) { /* ... (이전과 동일) ... */ }
function addErrorMessage(message) { /* ... (이전과 동일) ... */ }
function scrollToBottom() { /* ... (이전과 동일, 약간의 지연 포함) ... */ }

// --- Status UI ---
function createStatusUI(message = "처리 중...") {
    removeStatusUI();
    const container = document.createElement('div');
    container.id = 'status-container';
    container.innerHTML = `
        <span class="status-icon"><i class="fas fa-spinner fa-spin"></i></span>
        <span class="status-label">${escapeHtml(message)}</span>
    `;
    // Insert status UI *before* the chat input container now
    chatInputContainer.parentNode.insertBefore(container, chatInputContainer);
    scrollToBottom();
}
function removeStatusUI() { /* ... (이전과 동일) ... */ }

// --- Loading State ---
function setLoadingState(isLoading, statusMessage = "처리 중...") {
    userInput.disabled = isLoading;
    sendButton.disabled = isLoading;
    // 파일 입력 관련 UI 비활성화 제거

    if (isLoading) {
        createStatusUI(statusMessage);
    } else {
        removeStatusUI();
        if (!userInput.disabled) {
             userInput.focus();
        }
    }
    scrollToBottom();
}

/* ======== PDF File Handling (Fetching Predefined File) ======== */

// **Function to Fetch and Upload the Predefined PDF**
async function fetchAndUploadPredefinedPdf(pdfFilename) {
    // Optimization: If the same PDF was already uploaded, reuse the URI
    // Note: URIs might expire, so this is a basic optimization.
    // A more robust solution would check URI validity or re-upload periodically.
    if (uploadedFileUri && lastUploadedPdfName === pdfFilename) {
         log(`Reusing previously uploaded URI for ${pdfFilename}: ${uploadedFileUri}`);
         return uploadedFileUri;
    }

    log(`Attempting to fetch predefined PDF: ${pdfFilename}`);
    setLoadingState(true, `사전 정의된 PDF 로드 중: ${pdfFilename}...`);

    let pdfBlob;
    try {
        // Fetch the PDF file using its relative path (works only when served via HTTP/S)
        const response = await fetch(pdfFilename); // Request the file relative to the HTML

        if (!response.ok) {
            // Handle common errors like 404 Not Found
            let errorMsg = `HTTP error! Status: ${response.status}`;
             if (response.status === 404) {
                 errorMsg = `오류: PDF 파일 '${pdfFilename}'을 찾을 수 없습니다. HTML 파일과 같은 디렉토리에 있는지, 파일 이름이 정확한지, 웹 서버가 파일을 제공하는지 확인하세요.`;
             } else if (response.status === 0) { // Often indicates CORS or network error when using file:///
                 errorMsg = `오류: PDF 파일 '${pdfFilename}' 로드 실패. 네트워크 오류 또는 CORS 정책 때문일 수 있습니다. 페이지가 웹 서버를 통해 제공되는지 확인하세요 (file:/// 경로 아님).`;
             }
            throw new Error(errorMsg);
        }

        pdfBlob = await response.blob(); // Get the file content as a Blob
        log(`Successfully fetched PDF: ${pdfFilename}, Size: ${pdfBlob.size}, Type: ${pdfBlob.type}`);

        if (pdfBlob.size === 0) {
            throw new Error(`오류: 가져온 PDF 파일 '${pdfFilename}'의 내용이 비어 있습니다.`);
        }

    } catch (error) {
        log(`Error fetching predefined PDF '${pdfFilename}':`, error);
        addErrorMessage(`사전 정의된 PDF 로드 실패: ${error.message}`);
        setLoadingState(false); // Stop loading on fetch failure
        return null; // Indicate failure
    }

    // Now Upload the fetched Blob
    try {
        // Create a File object from the Blob to easily pass name and type
        const pdfFileObject = new File([pdfBlob], pdfFilename, { type: pdfBlob.type || 'application/pdf' });

        // Call the existing upload function
        const fileUri = await uploadPdfToGeminiInternal(pdfFileObject); // Renamed internal function

        if (fileUri) {
             lastUploadedPdfName = pdfFilename; // Store the name of the successfully uploaded PDF
        } else {
            lastUploadedPdfName = null; // Clear if upload failed
        }
        return fileUri;

    } catch (error) {
         // uploadPdfToGeminiInternal already logs and shows messages
         log("Error during upload after fetching:", error);
         lastUploadedPdfName = null;
         // Ensure loading state is turned off if upload fails here
         setLoadingState(false);
         return null;
    }
}


/* ======== GEMINI API INTERACTION (using REST API) ======== */

// **Internal Function to Upload PDF Blob/File using REST API**
// (Renamed from uploadPdfToGemini to avoid confusion)
async function uploadPdfToGeminiInternal(fileObject) { // Expects a File or Blob object
    if (!fileObject) return null;

    const fileName = fileObject.name || 'predefined.pdf'; // Use name from File object or default
    log(`Uploading PDF data for: ${fileName}`);
    // Update status message more accurately
    setLoadingState(true, `Gemini API로 PDF 업로드 중: ${fileName}...`);

    const uploadUrl = `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${geminiApiKey}`;

    try {
        const response = await fetch(uploadUrl, {
            method: 'POST',
            headers: {
                'Content-Type': fileObject.type || 'application/pdf',
                'X-Goog-Upload-File-Name': encodeURIComponent(fileName)
            },
            body: fileObject // Send the File or Blob object
        });

        const data = await response.json();

        if (!response.ok || data.error) {
            let errorMsg = `File API Error: ${data.error?.message || `HTTP ${response.status}`}`;
            // ... (rest of error handling as before) ...
             if (data.error?.details) { /* ... */ }
             if (response.status === 403) { /* ... */ }
            throw new Error(errorMsg);
        }

        const uploadedFile = data.file || data;
        if (!uploadedFile || !uploadedFile.uri) {
             console.error("Unexpected upload response structure:", data);
            throw new Error("File API Error: Upload response did not contain expected file URI.");
        }

        log(`PDF Uploaded Successfully. URI: ${uploadedFile.uri}`);
        uploadedFileUri = uploadedFile.uri; // Update global URI
        return uploadedFileUri;

    } catch (error) {
        log('PDF Upload Error:', error);
        // Modify error message slightly for context
        addErrorMessage(`PDF 파일 업로드 실패 (${fileName}): ${error.message}. CORS, API 키, 네트워크 상태를 확인하세요.`);
        uploadedFileUri = null;
        return null;
    }
    // Keep loading state, processMessage will handle turning it off
}

// **Function to get response based on uploaded PDF and question**
// (This function remains largely the same, just takes question and fileUri)
async function getGeminiResponsePdf(question, fileUri) {
    if (!geminiApiKey) return "오류: Gemini API 키가 누락되었습니다.";
    if (!fileUri) return "오류: PDF 파일 URI가 없습니다. 파일이 성공적으로 업로드되었는지 확인하세요.";

    log(`Sending request to Gemini with PDF URI: ${fileUri} and Question: ${question}`);
    setLoadingState(true, "Gemini 분석 중...");

    const systemPrompt = `당신은 "${PREDEFINED_PDF_FILENAME}" PDF 문서의 내용을 바탕으로 사용자의 질문에 한국어로 답변하는 AI 어시스턴트입니다.
- 제공된 PDF 파일("fileData")의 내용을 분석하고 사용자의 질문("text")에 답하세요.
- 답변은 반드시 PDF 파일 내의 정보에 근거해야 합니다. 파일에 없는 내용은 답변하지 마세요.
- 답변은 명확하고 간결하게, 전문가적인 톤으로 작성해주세요.
- Markdown 형식을 사용하여 가독성을 높일 수 있습니다(굵게, 기울임, 목록 등).`;

    const reqBody = {
        contents: [{
            role: "user",
            parts: [
                { text: `${systemPrompt}\n\n질문: ${question}` },
                 { fileData: { mimeType: "application/pdf", fileUri: fileUri } }
             ]
        }],
        safetySettings: [ /* ... (Standard safety settings) ... */ ],
        generationConfig: { temperature: 0.6 }
    };

    const model = "gemini-1.5-flash-latest";
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

    try {
        const resp = await fetch(url, {
            method: 'POST',
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(reqBody)
        });
        const data = await resp.json();

        // --- Error Handling (as before) ---
        if (!resp.ok || data.error) { /* ... (Detailed error handling) ... */ throw new Error(`Gemini API 오류: ${errorDetail}`); }
        if (!data.candidates || !data.candidates[0].content /* ... */) { /* ... (Handle empty/blocked response) ... */ return `오류: Gemini로부터 비어 있거나 차단된 응답...`; }

        let answer = data.candidates[0].content.parts[0].text;
        log("Gemini로부터 PDF 기반 응답 수신 완료.");

        // --- Markdown to HTML ---
        answer = answer.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') /* ... (rest of markdown conversion) ... */;
        return answer;

    } catch (err) {
        log('Gemini API fetch error:', err);
        // Use addErrorMessage directly here as it's the final step failure
        addErrorMessage(`Gemini 통신 오류: ${err.message}`);
        return null; // Indicate failure
    }
}

/* ======== MAIN MESSAGE PROCESSING ======== */
async function processMessage() {
    const userQuestion = userInput.value.trim();
    if (!userQuestion) return;

    addUserMessage(userQuestion);
    userInput.value = '';
    userInput.blur();

    setLoadingState(true, "작업 준비 중..."); // Initial state

    try {
        // 1. Fetch and Upload the *Predefined* PDF
        // The function now handles fetching and uploading internally
        const currentFileUri = await fetchAndUploadPredefinedPdf(PREDEFINED_PDF_FILENAME);

        if (!currentFileUri) {
            // Error message already shown by fetch or upload functions
            // Ensure loading state is off if fetch/upload failed early
            setLoadingState(false);
            return; // Stop processing
        }

        // 2. Get Response from Gemini using the obtained file URI
        const botResponse = await getGeminiResponsePdf(userQuestion, currentFileUri);

        // 3. Display Response or handle error
        if (botResponse) { // Check if response is not null (null indicates fetch error handled previously)
             if (botResponse.startsWith("오류:")) {
                  addErrorMessage(botResponse.replace(/^오류:\s*/, ''));
             } else {
                 addBotMessage(botResponse);
             }
        }
        // If botResponse is null, error was already displayed by getGeminiResponsePdf

    } catch (error) {
         // Catch any unexpected errors during the process
         log("Unexpected error in processMessage:", error);
         addErrorMessage(`처리 중 예상치 못한 오류 발생: ${error.message}`);
    } finally {
        // 4. Reset Loading State (ensure it's always turned off)
        setLoadingState(false);
    }
}

/* ======== EVENT LISTENERS ======== */
function handleSend() {
    const msg = userInput.value.trim();
    if (!sendButton.disabled && msg) { // Only check if not loading and message exists
        processMessage();
    } else if (!msg) {
        addErrorMessage("질문을 입력해주세요.");
    }
}

sendButton.addEventListener('click', handleSend);

userInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSend();
    }
});

// --- Initial Setup ---
userInput.focus();
log(`사전 정의된 PDF 봇 초기화 완료. 사용할 PDF: ${PREDEFINED_PDF_FILENAME}. 질문을 입력하세요.`);

</script>
</body>
</html>
